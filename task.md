# Asynchronous Communication

**Задача**: Для завдання з ЛР1 додати “event-sourcing” сутності створеної через CRUD-запити

## Завдання

1. Обрати message broker (рекомендовано Amazon SQS або RabbitMQ
2. Рівень 1: При створенні сутності чи її модифікації повідомлення повинно падати в чергу. \
Рівень 2-3: Реалізувати шаблон проєктування Transactional Outbox при відправці для забезпечення exactly-once обробки
3. Рівень 1: Створити сервіс-консьюмер, що споживатиме повідомлення з черги.  \
Рівень 2-3: Додати симуляцію випадкових помилок обробки (if random(5)>3 raise Exception). Реалізувати обробку “втрачених повідомлень” з допомогою Dead Letter Queue (просто залогуйте їй). Вітаю ви зробили майже компенсаторні транзакції SAGA
4. Тільки на рівень 3: Додати розподілене трасування логів. пропонується використовувати бібліотеки сумісні з OpenTracing  

## Зміст звіту

1. Мета роботи.
2. Завдання роботи.
3. Оформлення результатів роботи.
4. Діаграма компонентів системи. Діаграма потоку даних.
5. Опис коду програми.
6. Висновки.

### Контрольні питання

1. Що таке CQRS і які задачі вирішує даний шаблон
2. Оркестровка і хореографія
3. Опишіть як працюють брокери повідомлень, що таке visibility timeout
4. Які бувають гарантії доставки повідомлень
5. Optimistic vs pessimistic locking
6. Transactional outbox - що це і навіщо  
